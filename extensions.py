#Классы проекта

import json, requests;                          #импорт библиотек парсера и запросов

currency=["Евро","Доллар","Рубль"];             #Перечень валют

class Cur:                                      #Основной класс, содержащий главный метод
    def __init__(self):
        pass;
    @staticmethod
    def get_price(base, quote, amount):         #Аргументы <что измерить>, <в чём измерить> и <сколько этого чего>
        base_a=base;                            #Для "грамотного" написания названия валюты в зависимости от числа
        quote_a=quote;
        #Подготовим словарь. Да - парсинг возвращает много ненужной информации, и чтобы не пришлось копаться в ней слишком
        # глубоко, да и просто - упростить себе задачу. Заодно запишем в него сколнения написаний названий валют:
        val_dict={"Доллар США": ["USD", "Долларов США", "Доллара США"],
                  "Евро": ["EUR", "Евро", "Евро"],
                  "Российский рубль": ["RUB", "Российских рублей", "Российских рубля"]};
        src=requests.get("https://www.cbr-xml-daily.ru/daily_json.js");       #Кинем запрос к js-API
        js_val=json.loads(src.content)["Valute"];                             #Сразу выберем "подсловарь", который нас интересует
        #Использование этого API ограничено соглашениями и прочими препонами - не нужно злоупотреблять
        #Подставив значение из нашего словаря, вытянем из словаря с API цену на нашу валюту,..
        # а если это рубль, то поставим цену 1, т.к. в этом API рубль - базовая валюта
        cost_base=js_val.get(val_dict.get(base)[0]).get("Value") if base != "Российский рубль" else 1.0;
        cost_quote=js_val.get(val_dict.get(quote)[0]).get("Value") if quote != "Российский рубль" else 1.0;
        price=cost_base * float(amount) / cost_quote;                         #Простая формула и...
        if int(str(int(price))[-1:]) in (2,3,4):                              #.. и начнём подбирать грамотное написание
            quote_a=val_dict.get(quote)[2];                                   #.. названий валют, т.к. все "цифры" у нас уже есть
        if ((int(str(int(price))[-1:]) in (0, 5, 6, 7, 8, 9)) or (
                len(str(int(price))) >= 2 and 10 < int(str(int(price))[-2:]) < 20)):
            quote_a = val_dict.get(quote)[1];
        if int(str(int(amount))[-1:]) in (2,3,4):
            base_a=val_dict.get(base)[2];
        if ((int(str(int(amount))[-1:]) in (0, 5, 6, 7, 8, 9)) or (
                len(str(int(amount))) >= 2 and 10 < int(str(int(amount))[-2:]) < 20)):
            base_a=val_dict.get(base)[1];
        price=float("%.2f" % price);                                            #Расчёты дают много знаков после запятой - сократим до двух
        return f"За {amount} {base_a} сейчас просят {price} {quote_a}";         #Вернём сразу в виде читабельной и понятной фразы

class APIException(Exception):                  #Исключения
    def __init__(self, x=0):                    #В качестве аргумента будем передавать цифру методу, выводящему по ней нужное сообщение
        self.text="\nВозникла непредвиденная ошибка";
        if x==1:
            self.text="\nНеверно сформирован запрос";
        if x==2:
            self.text="\nОшибка при указании названия валюты";
        if x==3:
            self.text="\nНеверно указано количество валюты";
        if x==4:
            self.text="\nМогу посчитать только до одного миллиарда";
        if x==5:
            self.text="\nВозникла ошибка при расчетё соотношения стоимости валют";
    def __str__(self):
        return self.text;